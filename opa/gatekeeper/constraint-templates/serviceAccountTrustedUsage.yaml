apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: serviceaccounttrustedusage
  annotations:
    metadata.gatekeeper.sh/title: "ServiceAccount Trusted Usage"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Controls a k8s workloads ability to use use restricted service accounts.
      Workloads controlled by this constraint template are: ReplicationController, ReplicaSet, Deployment, StatefulSet, DaemonSet, Job, CronJob, Pod.
spec:
  crd:
    spec:
      names:
        kind: ServiceAccountTrustedUsage
      validation:
        openAPIV3Schema:
          type: object
          description: >-
            Controls a k8s workloads ability to use use restricted service accounts.
          properties:
            labels:
              type: array
              description: >-
                A list of labels and values the object must specify.
              items:
                type: object
                properties:
                  key:
                    type: string
                    description: >-
                      The required label.
                  allowedRegex:
                    type: string
                    description: >-
                      Regular expression the label's value must match. The value must contain one exact match for
                      the regular expression.
            restrictedServiceAccounts:
              type: array
              description: >-
                A list of restricted service accounts.
              items:
                type: string
                description: >-
                  The restricted service account name.
            trustedImages:
              type: array
              description: >-
                A list of trusted images. If a Pod match criteria from trustedImage, it is allowed to use restricted secret.
              items:
                type: object
                description: >-
                  The trusted image criteria.
                properties:
                  image:
                    type: string
                    description: >-
                      The container trusted image name.
                  command:
                    type: array
                    description: >-
                      The list of container trusted commands to run.
                    items:
                      type: string
                      description: >-
                        The trusted command to run.
                  args:
                    type: array
                    description: >-
                      The trusted arguments to pass to the command.
                    items:
                      type: string
                      description: >-
                        The trusted argument to pass to the command.
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package kubernetes.serviceaccounttrustedusage
        
          import future.keywords.contains
          import future.keywords.if
          import future.keywords.in
       
        # Report violation if the pod is using a restricted service account and does not match trusted usage criteria.
        
        violation contains {"msg": msg} if {
          some k
          # Iterate over all containers in the pod.
        
          container := input_containers[_]
        
          # Check if the pod is using a restricted service account.
        
          get_service_account(input.review.object) == input.parameters.restrictedServiceAccounts[k]
        
          # Check if the pod is not matching trusted usage criteria.
        
          not trustedUsages(container)
        
          # Format the violation message.
        
          msg := sprintf("Container %v is not allowed to use restricted service account: %v.", [container.name, input.parameters.restrictedServiceAccounts[k]])
        }
        
        # trustedUsages function checks if the pod is matching trusted usage criteria.
        # Trusted usage criteria are defined in the constraint template parameters.
        
        trustedUsages(container) if {
          some j
        
          # Check if the container is using a trusted image.
        
          glob.match(input.parameters.trustedImages[j].image, null, container.image)
        
          # Check if the container is using a trusted commands.
        
          checkCommand(container, input.parameters.trustedImages[j])
        
          # Check if the container is using a trusted arguments.
        
          checkArgs(container, input.parameters.trustedImages[j])
        
          # Check if the container has required labels.
        
          checkLabels(input.review.object, input.parameters)
        }
        
        # Check if trusted usage criteria does not define required labels.
        # Function evaluate too true if required labels are not defined.
        
        checkLabels(reviewObject, inputParameters) if {
          # Get the required labels from the constraint template parameters.
          # If the required labels are not defined, return empty array.
          # Empty array is required to prevent undefined expression result.
        
          paramLabels := object.get(inputParameters, "labels", [])
        
          # Check if the required labels array is empty.
        
          count(paramLabels) == 0
        
          # Getting pod labels to prevent unused variable error.
        
          _ := object.get(reviewObject.metadata, "labels", [])
        }
        
        # Check if the pod has required labels.
        checkLabels(reviewObject, inputParameters) if {
          # Check if the required labels array is not empty.
          paramLabels := object.get(inputParameters, "labels", [])
          count(paramLabels) > 0
        
          # Check if the pod labels array is not empty.
          reviewLabels := object.get(reviewObject.metadata, "labels", [])
          count(reviewLabels) > 0
        
          # Check if the pod has all required labels.
          value := reviewLabels[key]
          expected := input.parameters.labels[_]
          expected.key == key
        
          # Check if the pod label value matches the required labels regular expression.
          # If the required label does not define allowedRegex, use default value ".*" to match any value.
          reg := object.get(expected, "allowedRegex", ".*")
          regex.match(reg, value)
        }
        
        # Check if trusted usage criteria does not define trusted commands.
        # Function evaluate too true if trusted commands are not defined.
        checkCommand(container, trustedImage) if {
          trustedCommand := object.get(trustedImage, "command", [])
          count(trustedCommand) == 0
        
          # Getting container command to prevent unused variable error.
          _ := object.get(container, "command", [])
        }
        
        # Check if the container is using a trusted commands.
        # Function evaluate too true if the container is using exactly the same trusted commands.
        # Number and order of commands must match.
        checkCommand(container, trustedImage) if {
          trustedCommand := object.get(trustedImage, "command", [])
          containerCommand := object.get(container, "command", [])
          count(containerCommand) == count(trustedCommand)
        
          # Allow using wildcard to match variable part of the command.
          glob.match(trustedCommand[i], null, containerCommand[i])
        }
        
        # Check if trusted usage criteria does not define trusted arguments.
        # Function evaluate too true if trusted arguments are not defined.
        checkArgs(container, trustedImage) if {
          trustedArgs := object.get(trustedImage, "args", [])
          count(trustedArgs) == 0
        
          # Getting container args to prevent unused variable error.
          _ := object.get(container, "args", [])
        }
  
  
        # Check if the container is using a trusted arguments.
        # Function evaluate too true if the container is using exactly the same trusted arguments.
        # Number and order of commands must match.
        checkArgs(container, trustedImage) if {
          trustedArgs := object.get(trustedImage, "args", [])
          containerArgs := object.get(container, "args", [])
          count(containerArgs) == count(trustedArgs)
        
          # Allow using wildcard to match variable part of the argument.
          glob.match(trustedArgs[i], null, containerArgs[i])
        }
        
        # Get service account name from different type of k8s resources.
        get_service_account(obj) = spec if {
          obj.kind == "Pod"
          spec := obj.spec.serviceAccountName
        }
          
        get_service_account(obj) = spec if {
          obj.kind == "ReplicationController"
          spec := obj.spec.template.spec.serviceAccountName
        }
          
        get_service_account(obj) = spec if {
          obj.kind == "ReplicaSet"
          spec := obj.spec.template.spec.serviceAccountName
        }
          
        get_service_account(obj) = spec if {
          obj.kind == "Deployment"
          spec := obj.spec.template.spec.serviceAccountName
        }
          
        get_service_account(obj) = spec if {
          obj.kind == "StatefulSet"
          spec := obj.spec.template.spec.serviceAccountName
        }
          
        get_service_account(obj) = spec if {
          obj.kind == "DaemonSet"
          spec := obj.spec.template.spec.serviceAccountName
        }
          
        get_service_account(obj) = spec if {
          obj.kind == "Job"
          spec := obj.spec.template.spec.serviceAccountName
        }
          
        get_service_account(obj) = spec if {
          obj.kind == "CronJob"
          spec := obj.spec.jobTemplate.spec.template.spec.serviceAccountName
        }
        
        # Get all pod containers.
        input_containers contains c if {
          c := input.review.object.spec.containers[_]
        }
        
        # Get all pod init containers.
        input_containers contains c if {
          c := input.review.object.spec.initContainers[_]
        }
