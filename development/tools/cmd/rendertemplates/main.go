package main

import (
	"bytes"
	"encoding/gob"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/Masterminds/semver"
	"github.com/Masterminds/sprig"
	"github.com/forestgiant/sliceutil"
	"github.com/imdario/mergo"
	"gopkg.in/yaml.v2"
	"k8s.io/apimachinery/pkg/util/sets"
)

const (
	// autogenerationMessage is message added at the beginning of each autogenerated file.
	autogenerationMessage = "Code generated by rendertemplates. DO NOT EDIT."
)

var (
	configFilePath  = flag.String("config", "", "Path of the config file")
	additionalFuncs = map[string]interface{}{
		"matchingReleases": matchingReleases,
		"releaseMatches":   releaseMatches,
		"hasPresubmit":     hasPresubmit,
		"hasPostsubmit":    hasPostsubmit,
		"hasPeriodic":      hasPeriodic,
	}
	commentSignByFileExt = map[string]sets.String{
		"//": sets.NewString(".go"),
		"#":  sets.NewString(".yaml", ".yml"),
	}
)

func init() {
	gob.Register(map[string]interface{}{})
	gob.Register(map[interface{}]interface{}{})
	gob.Register([]interface{}{})
}

// Map performs a deep copy of the given map m.
func Map(m map[string]interface{}) (map[string]interface{}, error) {
	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)
	dec := gob.NewDecoder(&buf)
	err := enc.Encode(m)
	if err != nil {
		return nil, err
	}
	var copy map[string]interface{}
	err = dec.Decode(&copy)
	if err != nil {
		return nil, err
	}
	return copy, nil
}

// Config represents configuration of all templates to render along with global values
type Config struct {
	Templates  []TemplateConfig
	Global     map[string]interface{}
	GlobalSets map[string]ConfigSet `yaml:"globalSets,omitempty"`
}

// TemplateConfig specifies template to use and files to render
type TemplateConfig struct {
	From   string
	Render []RenderConfig
}

// RenderConfig specifies where to render template and values to use
type RenderConfig struct {
	To         string
	Values     map[string]interface{}
	LocalSets  map[string]ConfigSet `yaml:"localSets,omitempty"`
	JobConfigs []Repo               `yaml:"jobConfigs,omitempty"`
}

// ConfigSet hold set of data for generating prowjob from template
type ConfigSet map[string]interface{}

// Repo represent github repository with associated prowjobs data
type Repo struct {
	RepoName string `yaml:"repoName,omitempty"`
	Jobs     []Job  `yaml:"jobs,omitempty"`
}

// InheritedConfigs specify named configs to use for generating prowjob from template
type InheritedConfigs struct {
	Global []string `yaml:"global,omitempty"`
	Local  []string `yaml:"local,omitempty"`
}

// Job holds data for generating prowjob from template
type Job struct {
	InheritedConfigs InheritedConfigs `yaml:"inheritedConfigs,omitempty"`
	JobConfig        ConfigSet        `yaml:"jobConfig,omitempty"`
}

func main() {
	flag.Parse()

	if *configFilePath == "" {
		log.Fatal("Provide path to config file with --config")
	}

	configFile, err := ioutil.ReadFile(*configFilePath)
	if err != nil {
		log.Fatalf("Cannot read config file: %s", err)
	}

	config := new(Config)
	err = yaml.Unmarshal(configFile, config)
	if err != nil {
		log.Fatalf("Cannot parse config yaml: %s\n", err)
	}

	dataFilesDir := filepath.Join(filepath.Dir(*configFilePath), "data")
	// read all template configs from data files
	dataFiles, err := ioutil.ReadDir(dataFilesDir)
	var dataFilesTemplates []TemplateConfig
	for _, dataFile := range dataFiles {
		if !dataFile.IsDir() {
			var dataFileConfig Config
			var cfg bytes.Buffer
			// load datafile as template
			t, err := loadTemplate(dataFilesDir, dataFile.Name())
			if err != nil {
				log.Fatalf("Could not load data file %s: %v", dataFile.Name(), err)
			}
			// execute rendering the datafile from template and store it in-memory
			// at this point the config has all the global values from config.yaml file
			if err := t.Execute(&cfg, config); err != nil {
				log.Fatalf("Cannot render data template: %v", err)
			}
			if err := yaml.Unmarshal(cfg.Bytes(), &dataFileConfig); err != nil {
				log.Fatalf("Cannot parse data file yaml: %s\n", err)
			}
			dataFilesTemplates = append(dataFilesTemplates, dataFileConfig.Templates...)
		}

	}

	config.Templates = append(config.Templates, dataFilesTemplates...)

	for _, templateConfig := range config.Templates {
		err = renderTemplate(path.Dir(*configFilePath), templateConfig, config)
		if err != nil {
			log.Fatalf("Cannot render template %s: %s", templateConfig.From, err)
		}
	}
}

// TODO define errors?
func (r *RenderConfig) generateComponentJobs(global map[string]interface{}, globalConfigSets map[string]ConfigSet) {
	jobs := Repo{RepoName: r.Values["repository"].(string)}
	if r.Values["pushRepository"] == nil {
		log.Fatalln("Component jobs: missing \"pushrepository\" value.")
	}

	if r.Values["additionalRunIfChanged"] == nil {
		log.Fatalln("Component jobs: missing \"additionalRunIfChanged\" value.")
	}
	repository := strings.Split(r.Values["repository"].(string), "/")[2]

	commonLabels := map[string]interface{}{"preset-dind-enabled": "true", "preset-sa-gcr-push": "true", "preset-docker-push-repository-" + r.Values["pushRepository"].(string): "true"}
	commonGlobalConfigs := []string{"jobConfig_default", "image_buildpack-golang-kubebuilder2"}
	commonCommand := "/home/prow/go/src/github.com/kyma-project/test-infra/prow/scripts/build-generic.sh"
	commonArgs := []string{"/home/prow/go/src/" + r.Values["repository"].(string) + "/" + r.Values["path"].(string)}
	var commonOptional bool
	if r.Values["optional"] != nil {
		commonOptional = r.Values["optional"].(bool)
	}

	additionalRunIfChanged := make([]string, len(r.Values["additionalRunIfChanged"].([]interface{})))
	for i, add := range r.Values["additionalRunIfChanged"].([]interface{}) {
		additionalRunIfChanged[i] = add.(string)
	}

	commonRunIfChanged := "^" + r.Values["path"].(string) + "/|" + strings.Join(additionalRunIfChanged, "|")

	// generate jobs for the next release
	var preSubmit Job
	preSubmit.JobConfig = make(map[string]interface{})
	preSubmit.JobConfig["name"] = "pre-" + repository + "-" + strings.Replace(r.Values["path"].(string), "/", "-", -1)
	preSubmit.JobConfig["command"] = commonCommand
	preSubmit.JobConfig["args"] = commonArgs
	preSubmit.JobConfig["labels"] = commonLabels
	preSubmit.JobConfig["path_alias"] = r.Values["repository"]
	preSubmit.JobConfig["run_if_changed"] = commonRunIfChanged
	preSubmit.JobConfig["optional"] = commonOptional
	preSubmit.InheritedConfigs.Global = commonGlobalConfigs
	preSubmit.InheritedConfigs.Global = append(preSubmit.InheritedConfigs.Global, "jobConfig_presubmit", "extra_refs_test-infra")
	jobs.Jobs = append(jobs.Jobs, preSubmit)

	var postSubmit Job
	postSubmit.JobConfig = make(map[string]interface{})
	postSubmit.JobConfig["name"] = "post-" + repository + "-" + strings.Replace(r.Values["path"].(string), "/", "-", -1)
	postSubmit.JobConfig["command"] = commonCommand
	postSubmit.JobConfig["args"] = commonArgs
	postSubmit.JobConfig["labels"] = commonLabels
	postSubmit.JobConfig["path_alias"] = r.Values["repository"]
	postSubmit.JobConfig["run_if_changed"] = commonRunIfChanged
	postSubmit.JobConfig["optional"] = commonOptional
	postSubmit.InheritedConfigs.Global = commonGlobalConfigs
	postSubmit.InheritedConfigs.Global = append(postSubmit.InheritedConfigs.Global, "jobConfig_postsubmit", "extra_refs_test-infra", "disable_testgrid")
	jobs.Jobs = append(jobs.Jobs, postSubmit)
	// generate jobs for the previous releases
	if r.Values["skipReleaseJobs"] == nil || r.Values["skipReleaseJobs"].(string) != "true" {
		for _, currentRelease := range global["releases"].([]interface{}) {
			rel := currentRelease.(string)
			commonRelBranches := []string{"release-" + rel}
			commonExtrarefsTestInfra := map[string]interface{}{"test-infra": []map[string]interface{}{{"org": "kyma-project", "repo": "test-infra", "path_alias": "github.com/kyma-project/test-infra", "base_ref": "release-" + rel}}}

			var preSubmitRel Job
			preSubmitRel.JobConfig = make(map[string]interface{})
			preSubmitRel.JobConfig["name"] = "pre-rel" + strings.Replace(rel, ".", "", -1) + "-" + repository + "-" + strings.Replace(r.Values["path"].(string), "/", "-", -1)
			preSubmitRel.JobConfig["command"] = commonCommand
			preSubmitRel.JobConfig["args"] = commonArgs
			preSubmitRel.JobConfig["labels"] = commonLabels
			preSubmitRel.JobConfig["branches"] = commonRelBranches
			preSubmitRel.JobConfig["path_alias"] = r.Values["repository"]
			preSubmitRel.JobConfig["run_if_changed"] = commonRunIfChanged
			preSubmitRel.JobConfig["optional"] = commonOptional
			preSubmitRel.JobConfig["extra_refs"] = commonExtrarefsTestInfra
			preSubmitRel.InheritedConfigs.Global = commonGlobalConfigs
			preSubmitRel.InheritedConfigs.Global = append(preSubmitRel.InheritedConfigs.Global, "jobConfig_presubmit")
			jobs.Jobs = append(jobs.Jobs, preSubmitRel)

			var postSubmitRel Job
			postSubmitRel.JobConfig = make(map[string]interface{})
			postSubmitRel.JobConfig["name"] = "post-rel" + strings.Replace(rel, ".", "", -1) + "-" + repository + "-" + strings.Replace(r.Values["path"].(string), "/", "-", -1)
			postSubmitRel.JobConfig["command"] = commonCommand
			postSubmitRel.JobConfig["args"] = commonArgs
			postSubmitRel.JobConfig["labels"] = commonLabels
			postSubmitRel.JobConfig["branches"] = commonRelBranches
			postSubmitRel.JobConfig["path_alias"] = r.Values["repository"]
			postSubmitRel.JobConfig["run_if_changed"] = commonRunIfChanged
			postSubmitRel.JobConfig["optional"] = commonOptional
			postSubmitRel.JobConfig["extra_refs"] = commonExtrarefsTestInfra
			postSubmitRel.InheritedConfigs.Global = commonGlobalConfigs
			postSubmitRel.InheritedConfigs.Global = append(postSubmitRel.InheritedConfigs.Global, "jobConfig_postsubmit", "disable_testgrid")
			jobs.Jobs = append(jobs.Jobs, postSubmitRel)
		}
	}

	r.JobConfigs = append(r.JobConfigs, jobs)
}

func (r *RenderConfig) mergeConfigs(config *Config) {
	globalConfigSets := config.GlobalSets
	if present := len(r.JobConfigs); present > 0 {
		r.Values = make(map[string]interface{})
		for repoIndex, repo := range r.JobConfigs {
			for jobIndex, job := range repo.Jobs {
				jobConfig := ConfigSet{}
				if sliceutil.Contains(job.InheritedConfigs.Global, "default") {
					if err := jobConfig.mergeConfigSet(deepCopyConfigSet(globalConfigSets["default"])); err != nil {
						log.Fatalf("Failed merge Global default configSet: %s", err)
					}

				}
				if sliceutil.Contains(job.InheritedConfigs.Local, "default") {
					if err := jobConfig.mergeConfigSet(deepCopyConfigSet(r.LocalSets["default"])); err != nil {
						log.Fatalf("Failed merge Local default configSet: %s", err)
					}
				}
				for _, v := range job.InheritedConfigs.Global {
					if v != "default" {
						if err := jobConfig.mergeConfigSet(deepCopyConfigSet(globalConfigSets[v])); err != nil {
							log.Fatalf("Failed merge global %s named configset: %s", v, err)
						}
					}
				}
				for _, v := range job.InheritedConfigs.Local {
					if v != "default" {
						if err := jobConfig.mergeConfigSet(deepCopyConfigSet(r.LocalSets[v])); err != nil {
							log.Fatalf("Failed merge local %s named configset: %s", v, err)
						}
					}
				}
				if err := jobConfig.mergeConfigSet(job.JobConfig); err != nil {
					log.Fatalf("Failed merge job configset %s", err)
				}

				compareAgainstRelease := config.Global["nextRelease"]
				if jobConfig["release_current"] != nil {
					compareAgainstRelease = jobConfig["release_current"]
				}

				if releaseMatches(compareAgainstRelease, jobConfig["release_since"], jobConfig["release_until"]) {
					r.JobConfigs[repoIndex].Jobs[jobIndex].JobConfig = jobConfig
				}
			}
		}
		r.Values["JobConfigs"] = r.JobConfigs
	}
}

func deepCopyConfigSet(configSet ConfigSet) ConfigSet {
	dst, err := Map(configSet)
	if err != nil {
		log.Fatalf("Failed ConfigSet deepCopy with error: %s", err)
	}
	return dst
}

func (j *ConfigSet) mergeConfigSet(configSet ConfigSet) error {
	if len(configSet) == 0 {
		return errors.New("configSet not found")
	}
	if err := mergo.Merge(j, configSet, mergo.WithOverride); err != nil {
		return err
	}
	return nil
}

func renderTemplate(basePath string, templateConfig TemplateConfig, config *Config) error {
	templateInstance, err := loadTemplate(basePath, templateConfig.From)
	if err != nil {
		return err
	}
	for _, render := range templateConfig.Render {

		if render.Values["repository"] != nil {
			render.generateComponentJobs(config.Global, config.GlobalSets)
		}

		render.mergeConfigs(config)
		err = renderFileFromTemplate(basePath, templateInstance, render, config)
		if err != nil {
			log.Printf("Failed render %s file", render.To)
			return err
		}
	}

	return nil
}

func renderFileFromTemplate(basePath string, templateInstance *template.Template, renderConfig RenderConfig, config *Config) error {
	relativeDestPath := path.Join(basePath, renderConfig.To)

	destDir := path.Dir(relativeDestPath)
	err := os.MkdirAll(destDir, os.ModePerm)
	if err != nil {
		return err
	}

	destFile, err := os.Create(relativeDestPath)
	if err != nil {
		return err
	}

	if err := addAutogeneratedHeader(destFile); err != nil {
		return err
	}

	values := map[string]interface{}{"Values": renderConfig.Values, "Global": config.Global}

	return templateInstance.Execute(destFile, values)
}

func loadTemplate(basePath, templatePath string) (*template.Template, error) {
	relativeTemplatePath := path.Join(basePath, templatePath)
	return template.
		New(path.Base(templatePath)).
		Funcs(sprig.TxtFuncMap()).
		Funcs(additionalFuncs).
		ParseFiles(relativeTemplatePath)
}

func matchingReleases(allReleases []interface{}, since interface{}, until interface{}) []interface{} {
	result := make([]interface{}, 0)
	for _, rel := range allReleases {
		if releaseMatches(rel, since, until) {
			result = append(result, rel)
		}
	}
	return result
}

func releaseMatches(rel interface{}, since interface{}, until interface{}) bool {
	relVer := semver.MustParse(rel.(string))
	if since != nil && relVer.Compare(semver.MustParse(since.(string))) < 0 {
		return false
	}
	if until != nil && relVer.Compare(semver.MustParse(until.(string))) > 0 {
		return false
	}
	return true
}

func addAutogeneratedHeader(destFile *os.File) error {
	outputExt := filepath.Ext(destFile.Name())
	sign, err := commentSign(outputExt)
	if err != nil {
		return err
	}

	header := fmt.Sprintf("%s %s\n\n", sign, autogenerationMessage)
	if _, err := destFile.WriteString(header); err != nil {
		return err
	}

	return nil
}

func commentSign(extension string) (string, error) {
	for sign, extFile := range commentSignByFileExt {
		if extFile.Has(extension) {
			return sign, nil
		}
	}
	return "", fmt.Errorf("cannot add autogenerated header comment: unknow comment sign for %q file extension", extension)
}

// hasProwjobType check if prowjobtype value is present in prowjob configs.
func hasProwjobType(r []Repo, prowjobtype string) bool {
	for _, repo := range r {
		for _, job := range repo.Jobs {
			if _, ok := job.JobConfig[prowjobtype]; ok {
				return ok
			}
		}
	}
	return false
}

// hasPresubmit check if any prowjob is type_presubmit
func hasPresubmit(r []Repo) bool {
	return hasProwjobType(r, "type_presubmit")
}

// hasPresubmit check if any prowjob is type_postsubmit
func hasPostsubmit(r []Repo) bool {
	return hasProwjobType(r, "type_postsubmit")
}

// hasPresubmit check if any prowjob is type_periodic
func hasPeriodic(r []Repo) bool {
	return hasProwjobType(r, "type_periodic")
}
