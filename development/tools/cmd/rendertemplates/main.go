package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"text/template"

	"github.com/Masterminds/semver"
	"github.com/Masterminds/sprig"
	"github.com/forestgiant/sliceutil"
	"github.com/imdario/mergo"
	"gopkg.in/yaml.v2"
	"k8s.io/apimachinery/pkg/util/sets"
)

const (
	// autogenerationMessage is message added at the beginning of each autogenerated file.
	autogenerationMessage = "Code generated by rendertemplates. DO NOT EDIT."
)

var (
	configFilePath  = flag.String("config", "", "Path of the config file")
	additionalFuncs = map[string]interface{}{
		"matchingReleases": matchingReleases,
		"releaseMatches":   releaseMatches,
	}
	commentSignByFileExt = map[string]sets.String{
		"//": sets.NewString(".go"),
		"#":  sets.NewString(".yaml", ".yml"),
	}
	imageRegex = regexp.MustCompile(`(?i)^.*(global|values)\.images\.(?P<imageName>.*$)`)
)

// Config represents configuration of all templates to render along with global values
type Config struct {
	Templates []TemplateConfig
	Global    map[string]interface{}
	//GlobalSets map[string]ConfigSet `yaml:"globalSets,omitempty"`
	GlobalSets ConfigSets `yaml:"globalSets,omitempty"`
}

// TemplateConfig specifies template to use and files to render
type TemplateConfig struct {
	From   string
	Render []RenderConfig
}

// RenderConfig specifies where to render template and values to use
type RenderConfig struct {
	To     string
	Values map[string]interface{}
	//LocalSets map[string]ConfigSet `yaml:"localSets,omitempty"`
	LocalSets  ConfigSets `yaml:"localSets,omitempty"`
	JobConfigs []Repo     `yaml:"jobConfigs,omitempty"`
}

type ConfigSets map[string]map[string]interface{}

type ConfigSet map[string]interface{}

type Repo struct {
	RepoName string `yaml:"repoName,omitempty"`
	Jobs     []Job  `yaml:"jobs,omitempty"`
}

type InheritedConfigs struct {
	Global []string `yaml:"global,omitempty"`
	Local  []string `yaml:"local,omitempty"`
}
type Job struct {
	InheritedConfigs InheritedConfigs `yaml:"inheritedConfigs,omitempty"`
	//JobConfig	ConfigSet `yaml:"jobConfig,omitempty"`
	JobConfig map[string]interface{} `yaml:"jobConfig,omitempty"`
	labels    map[string]interface{}
	envs      []map[string]interface{}
}

type JobConfig map[string]interface{}

type ConfigMergeOpts struct {
	OverrideLabels bool
	OverrideEnvs   bool
}

func main() {
	flag.Parse()

	if *configFilePath == "" {
		log.Fatal("Provide path to config file with --config")
	}

	configFile, err := ioutil.ReadFile(*configFilePath)
	if err != nil {
		log.Fatalf("Cannot read config file: %s", err)
	}

	config := new(Config)
	err = yaml.Unmarshal(configFile, config)
	if err != nil {
		log.Fatalf("Cannot parse config yaml: %s\n", err)
	}

	for _, templateConfig := range config.Templates {
		err = renderTemplate(path.Dir(*configFilePath), templateConfig, config)
		if err != nil {
			log.Fatalf("Cannot render template %s: %s", templateConfig.From, err)
		}
	}
}

//func (r *RenderConfig) mergeConfigs(globalConfigSets map[string]ConfigSet) {
func (r *RenderConfig) mergeConfigs(globalConfigSets ConfigSets) {
	if present := len(r.JobConfigs); present > 0 {
		r.Values = make(map[string]interface{})
		for repoIndex, repo := range r.JobConfigs {
			for jobIndex, job := range repo.Jobs {
				//jobConfig := ConfigSet{}
				jobConfig := make(map[string]interface{})
				//if sliceutil.Contains(job.InheritedConfigs.Global, "default") {
				//if err := jobConfig.mergeConfigSet(globalConfigSets["default"]); err != nil {
				//	if err := mergeConfigSet(&jobConfig, globalConfigSets["default"]); err != nil {
				//		log.Fatalf("Failed merge Global default configSet: %s", err)
				//	}

				//}
				if sliceutil.Contains(job.InheritedConfigs.Local, "default") {
					//if err := jobConfig.mergeConfigSet(r.LocalSets["default"]); err != nil {
					if err := mergeConfigSet(&jobConfig, r.LocalSets["default"]); err != nil {
						log.Fatalf("Failed merge Local default configSet: %s", err)
					}
				}
				//for _, v := range job.InheritedConfigs.Global {
				//	if v != "default" {
				//		//if err := jobConfig.mergeConfigSet(globalConfigSets[v]); err != nil {
				//		if err := mergeConfigSet(&jobConfig, globalConfigSets[v]); err != nil {
				//			log.Fatalf("Failed merge global %s named configset: %s", v, err)
				//		}
				//	}
				//}
				//for _, v := range job.InheritedConfigs.Local {
				//	if v != "default" {
				//		//if err := jobConfig.mergeConfigSet(r.LocalSets[v]); err != nil {
				//		if err := mergeConfigSet(&jobConfig, r.LocalSets[v]); err != nil {
				//			log.Fatalf("Failed merge local %s named configset: %s", v, err)
				//		}
				//	}
				//}
				//if err := jobConfig.mergeConfigSet(job.JobConfig); err != nil {
				if err := mergeConfigSet(&jobConfig, job.JobConfig); err != nil {
					log.Fatalf("Failed merge job configset %s", err)
				}
				r.JobConfigs[repoIndex].Jobs[jobIndex].JobConfig = jobConfig
			}
		}
		r.Values["JobConfigs"] = r.JobConfigs
	}
}

//func (j *ConfigSet) mergeConfigSet(configSet ConfigSet) error {
func mergeConfigSet(dst *map[string]interface{}, configSet map[string]interface{}) error {
	if len(configSet) == 0 {
		return errors.New("configSet not found")
	}
	if err := mergo.Merge(dst, configSet, mergo.WithOverride); err != nil {
		return err
	}
	return nil
}

//func (j *Job) mergeLabels(configSet ConfigSet, opts ...func(*ConfigMergeOpts)) error {
//	configMergeOpts := &ConfigMergeOpts{}
//	for _, opt := range opts {
//		opt(configMergeOpts)
//	}
//	if value, present := configSet["labels"]; present {
//		if err := mergo.Merge(j.labels, value); err != nil {
//			return err
//		}
//	}
//	return nil
//}

//func mergeEnvs {

//}

func renderTemplate(basePath string, templateConfig TemplateConfig, config *Config) error {
	templateInstance, err := loadTemplate(basePath, templateConfig.From)
	if err != nil {
		return err
	}
	for _, render := range templateConfig.Render {
		render.mergeConfigs(config.GlobalSets)
		err = renderFileFromTemplate(basePath, templateInstance, render, config)
		if err != nil {
			return err
		}
	}

	return nil
}

func renderFileFromTemplate(basePath string, templateInstance *template.Template, renderConfig RenderConfig, config *Config) error {
	relativeDestPath := path.Join(basePath, renderConfig.To)

	destDir := path.Dir(relativeDestPath)
	err := os.MkdirAll(destDir, os.ModePerm)
	if err != nil {
		return err
	}

	destFile, err := os.Create(relativeDestPath)
	if err != nil {
		return err
	}

	if err := addAutogeneratedHeader(destFile); err != nil {
		return err
	}

	values := map[string]interface{}{"Values": renderConfig.Values, "Global": config.Global}

	return templateInstance.Execute(destFile, values)
}

func loadTemplate(basePath, templatePath string) (*template.Template, error) {
	relativeTemplatePath := path.Join(basePath, templatePath)
	return template.
		New(path.Base(templatePath)).
		Funcs(sprig.TxtFuncMap()).
		Funcs(additionalFuncs).
		ParseFiles(relativeTemplatePath)
}

func matchingReleases(allReleases []interface{}, since interface{}, until interface{}) []interface{} {
	result := make([]interface{}, 0)
	for _, rel := range allReleases {
		if releaseMatches(rel, since, until) {
			result = append(result, rel)
		}
	}
	return result
}

func releaseMatches(rel interface{}, since interface{}, until interface{}) bool {
	relVer := semver.MustParse(rel.(string))
	if since != nil && relVer.Compare(semver.MustParse(since.(string))) < 0 {
		return false
	}
	if until != nil && relVer.Compare(semver.MustParse(until.(string))) > 0 {
		return false
	}
	return true
}

func addAutogeneratedHeader(destFile *os.File) error {
	outputExt := filepath.Ext(destFile.Name())
	sign, err := commentSign(outputExt)
	if err != nil {
		return err
	}

	header := fmt.Sprintf("%s %s\n\n", sign, autogenerationMessage)
	if _, err := destFile.WriteString(header); err != nil {
		return err
	}

	return nil
}

func commentSign(extension string) (string, error) {
	for sign, extFile := range commentSignByFileExt {
		if extFile.Has(extension) {
			return sign, nil
		}
	}
	return "", fmt.Errorf("cannot add autogenerated header comment: unknow comment sign for %q file extension", extension)
}
