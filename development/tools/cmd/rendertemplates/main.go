package main

import (
	"bytes"
	"encoding/gob"
	"flag"
	"fmt"
	"io/fs"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig"
	"gopkg.in/yaml.v2"
	"k8s.io/apimachinery/pkg/util/sets"

	rt "github.com/kyma-project/test-infra/development/tools/pkg/rendertemplates"
)

const (
	// autogenerationMessage is message added at the beginning of each autogenerated file.
	autogenerationMessage = "Code generated by rendertemplates. DO NOT EDIT."
)

var (
	configFilePath = flag.String("config", "", "Path of the config file")
	showOutputDir  = flag.Bool("show-output-dir", false, "Print generated output file paths to stdout")
	skipDataDir    = flag.Bool("skip-data-dir", false, "Do not process data directory.")

	additionalFuncs = map[string]interface{}{
		"matchingReleases": rt.MatchingReleases,
		"releaseMatches":   rt.ReleaseMatches,
		"hasPresubmit":     hasPresubmit,
		"hasPostsubmit":    hasPostsubmit,
		"hasPeriodic":      hasPeriodic,
		"getRunId":         getRunID,
	}
	commentSignByFileExt = map[string]sets.String{
		"//": sets.NewString(".go"),
		"> ": sets.NewString(".md"),
		"#":  sets.NewString(".yaml", ".yml"),
	}
)

func init() {
	gob.Register(map[string]interface{}{})
	gob.Register(map[interface{}]interface{}{})
	gob.Register([]interface{}{})
}

func main() {
	flag.Parse()

	if *configFilePath == "" {
		log.Fatal("Provide path to config file with --config")
	}

	// read template config file containing global configsets
	configFile, err := ioutil.ReadFile(*configFilePath)
	if err != nil {
		log.Fatalf("Cannot read config file: %s", err)
	}

	config := new(rt.Config)
	err = yaml.Unmarshal(configFile, config)
	if err != nil {
		log.Fatalf("Cannot parse config yaml: %s\n", err)
	}

	if !*skipDataDir {
		dataFilesDir := filepath.Join(filepath.Dir(*configFilePath), "data")
		// read all template data from data files
		var dataFiles []string
		err = filepath.Walk(dataFilesDir, getFileWalkFunc(dataFilesDir, &dataFiles))
		if err != nil {
			log.Fatalf("Cannot read data file directory: %s", err)
		}

		var dataFilesTemplates []*rt.TemplateConfig
		for _, dataFile := range dataFiles {
			var dataFileConfig rt.Config
			var cfg bytes.Buffer
			// load datafile as template
			t, err := loadTemplate(dataFilesDir, dataFile)
			if err != nil {
				log.Fatalf("Could not load data file %s: %v", dataFile, err)
			}
			// execute rendering the datafile from template and store it in-memory
			// at this point the config has all the global values from config.yaml file
			if err := t.Execute(&cfg, config); err != nil {
				log.Fatalf("Cannot render data template: %v", err)
			}
			if err := yaml.Unmarshal(cfg.Bytes(), &dataFileConfig); err != nil {
				log.Fatalf("Cannot parse data file yaml: %s\n", err)
			}
			dataFilesTemplates = append(dataFilesTemplates, dataFileConfig.Templates...)
		}

		// append all generated configs from datafiles to the list of templates to generate jobs from
		config.Templates = append(config.Templates, dataFilesTemplates...)
	}

	config.Merge()

	// generate final .yaml files
	for _, templateConfig := range config.Templates {
		err = renderTemplate(path.Dir(*configFilePath), templateConfig, config)
		if err != nil {
			log.Fatalf("Cannot render template %s: %s", templateConfig.From, err)
		}
	}
}

// getFileWalkFunc returns walk function that will recursively find YAML files and will return list of these files
func getFileWalkFunc(dataFilesDir string, dataFiles *[]string) filepath.WalkFunc {
	return func(path string, info fs.FileInfo, err error) error {
		// pass the error further, this shouldn't ever happen
		if err != nil {
			return err
		}

		// skip directory entries, we just want files
		if info.IsDir() {
			return nil
		}

		// we only want to check .yaml files
		if !strings.Contains(info.Name(), ".yaml") {
			return nil
		}

		// get relative path
		dataFile := strings.Replace(path, dataFilesDir, "", -1)
		// add all YAML files to the list
		*dataFiles = append(*dataFiles, dataFile)

		return nil
	}
}

// renderTemplate loads the template and calls the function that renders final files
func renderTemplate(basePath string, templateConfig *rt.TemplateConfig, config *rt.Config) error {
	for _, fromTo := range templateConfig.FromTo {
		if *showOutputDir {
			log.Printf("Rendering %s", fromTo)
		}
		templateInstance, err := loadTemplate(basePath, fromTo.From)
		if err != nil {
			return err
		}
		for _, render := range templateConfig.Render {
			err = renderFileFromTemplate(basePath, templateInstance, *render, config, fromTo)
			if err != nil {
				log.Printf("Failed render %s file", fromTo.To)
				return err
			}
		}
	}

	return nil
}

// renderFileFromTemplate renders template to file, based on the data passed to the template
func renderFileFromTemplate(basePath string, templateInstance *template.Template, renderConfig rt.RenderConfig, config *rt.Config, fromTo rt.FromTo) error {
	relativeDestPath := path.Join(basePath, fromTo.To)

	destDir := path.Dir(relativeDestPath)
	err := os.MkdirAll(destDir, os.ModePerm)
	if err != nil {
		return err
	}

	destFile, err := os.Create(relativeDestPath)
	if err != nil {
		return err
	}

	if err := addAutogeneratedHeader(destFile); err != nil {
		return err
	}

	values := map[string]interface{}{"Values": renderConfig.Values, "Global": config.Global}

	return templateInstance.Execute(destFile, values)
}

func loadTemplate(basePath, templatePath string) (*template.Template, error) {
	relativeTemplatePath := path.Join(basePath, templatePath)
	return template.
		New(path.Base(templatePath)).
		Funcs(sprig.TxtFuncMap()).
		Funcs(additionalFuncs).
		ParseFiles(relativeTemplatePath)
}

func addAutogeneratedHeader(destFile *os.File) error {
	outputExt := filepath.Ext(destFile.Name())
	sign, err := commentSign(outputExt)
	if err != nil {
		return err
	}

	header := fmt.Sprintf("%s %s\n\n", sign, autogenerationMessage)
	if _, err := destFile.WriteString(header); err != nil {
		return err
	}

	return nil
}

func commentSign(extension string) (string, error) {
	for sign, extFile := range commentSignByFileExt {
		if extFile.Has(extension) {
			return sign, nil
		}
	}
	return "", fmt.Errorf("cannot add autogenerated header comment: unknow comment sign for %q file extension", extension)
}

// hasProwjobType check if prowjobtype value is present in prowjob configs.
func hasProwjobType(r []rt.Repo, prowjobtype string) bool {
	for _, repo := range r {
		for _, job := range repo.Jobs {
			if _, ok := job.JobConfig[prowjobtype]; ok {
				return ok
			}
		}
	}
	return false
}

// hasPresubmit check if any prowjob is type_presubmit
func hasPresubmit(r []rt.Repo) bool {
	return hasProwjobType(r, "type_presubmit")
}

// hasPresubmit check if any prowjob is type_postsubmit
func hasPostsubmit(r []rt.Repo) bool {
	return hasProwjobType(r, "type_postsubmit")
}

// hasPresubmit check if any prowjob is type_periodic
func hasPeriodic(r []rt.Repo) bool {
	return hasProwjobType(r, "type_periodic")
}

// getRunID trims the prowjob name to 63 characters and makes sure it doesn't end with dash to match pubsub requirements.
func getRunID(name interface{}) string {
	jobName := name.(string)
	if len(jobName) > 63 {
		jobName = jobName[0:63]
		for jobName[len(jobName)-1:] == "-" {
			jobName = jobName[:len(jobName)-1]
		}
	}
	return "\"" + jobName + "\""
}
