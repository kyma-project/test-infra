package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"strings"

	grafeas "google.golang.org/genproto/googleapis/grafeas/v1"

	log "github.com/sirupsen/logrus"

	"github.com/kyma-project/test-infra/development/tools/pkg/vulnerabilitycollector"
)

var (
	project     = flag.String("project", "", "Project ID [Required]")
	projectPath = flag.String("path", "", "Specify a sub-path in the project if you don't want to run against all public images")
	region      = flag.String("region", "", "Region shortcode, eu for Europe, us for United States, leave empty for global")
	dryRun      = flag.Bool("dryRun", true, "Dry Run enabled, google apis are not called, explictitly set to false")
)

func main() {
	ctx := context.Background()
	flag.Parse()

	if *project == "" {
		fmt.Fprintln(os.Stderr, "missing -project flag")
		flag.Usage()
		os.Exit(2)
	}

	if *region == "" && *region != "us" && *region != "eu" {
		fmt.Fprintln(os.Stderr, "missing proper value for -region flag")
		flag.Usage()
		os.Exit(2)
	}

	changePrefix := ""
	if *dryRun {
		changePrefix = "[DRYRUN] "
	}

	imageList, err := vulnerabilitycollector.GetLatestImageList(ctx, *project, *region, *projectPath, !*dryRun)
	if err != nil {
		log.Fatalf("Couldn't get image list from Google Container registry: %s", err.Error())
	}

	var totalHighSeverityIssues int
	var occurenceList []*grafeas.Occurrence
	for _, url := range imageList {
		vs, err := vulnerabilitycollector.FindVulnerabilityOccurrencesForImage(ctx, *project, !*dryRun, url)
		if err != nil {
			log.Errorf("Could not get vulnerabilities: %v", err)
		}

		log.Infof("Collecting vulnerabilities for %s", url)

		var totalNumberOfIssuesOnProject = len(vs)
		var countHighSeverityIssues int
		for _, element := range vs {
			occurence := element.GetVulnerability()
			if occurence != nil {
				if strings.Contains("HIGH", occurence.Severity.String()) {
					for _, oc := range occurence.PackageIssue {
						if oc.GetFixAvailable() {
							log.Warnf("Severity '%s' for package '%s' with version '%s'. Known fix in version '%s'", occurence.Severity.String(), oc.GetAffectedPackage(), oc.GetAffectedVersion().GetFullName(), oc.GetFixedVersion().GetFullName())
						} else {
							log.Warnf("Severity '%s' for package '%s' with version '%s'. No known fix available.", occurence.Severity.String(), oc.GetAffectedPackage(), oc.GetAffectedVersion().GetFullName())
						}
					}
					countHighSeverityIssues++
				}
			}
		}
		if totalNumberOfIssuesOnProject > 0 {
			log.Warnf("%s%d of %d issues were of severity HIGH", changePrefix, countHighSeverityIssues, totalNumberOfIssuesOnProject)
		}
		totalHighSeverityIssues = totalHighSeverityIssues + countHighSeverityIssues
		occurenceList = append(occurenceList, vs...)
	}
	var totalNumberOfIssues = len(occurenceList)

	log.Infof("%sFound %d vulnerabilities for specified project when checking %d containers", changePrefix, totalNumberOfIssues, len(imageList))

	vulnerabilitycollector.WriteToSlack(!*dryRun, fmt.Sprintf("Checked %d containers and found a total of %d vulnerabilities", len(imageList), totalNumberOfIssues), totalHighSeverityIssues, totalNumberOfIssues)

}
