package vulnerabilitycollector

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strconv"
	"strings"

	log "github.com/sirupsen/logrus"

	containeranalysis "cloud.google.com/go/containeranalysis/apiv1beta1"
	"github.com/nlopes/slack"
	"google.golang.org/api/iterator"
	grafeaspb "google.golang.org/genproto/googleapis/devtools/containeranalysis/v1beta1/grafeas"
)

// GetLatestImageList queries the gcr.io repository in the given region, with the given sub-path
// on a given project and returns the latest pushed image of that path.
func GetLatestImageList(ctx context.Context, project, region, path string, doChanges bool) ([]string, error) {
	var imageUrls []string

	if doChanges {
		urls, err := collectLatestImageUrls(ctx, project, region, path)
		if err != nil {
			return []string{}, err
		}
		imageUrls = append(imageUrls, urls...)
	}

	return imageUrls, nil
}

type gcrAPIResponse struct {
	Children  []string                                `json:"child"`
	Manifests map[string]gcrAPIResponseDockerManifest `json:"manifest"`
}

type gcrAPIResponseDockerManifest struct {
	TimeCreatedMs string `json:"timeCreatedMs"`
}

func collectLatestImageUrls(ctx context.Context, project, region, path string) ([]string, error) {
	var gcrURL string
	var regionStr string
	if region != "" {
		regionStr = fmt.Sprintf("%s.", region)
	}
	if path != "" && !strings.HasPrefix(path, "/") {
		path = fmt.Sprintf("/%s", path)
	}
	gcrURL = fmt.Sprintf("https://%sgcr.io/v2/%s%s/tags/list", regionStr, project, path)
	log.Infof("Collecting info for %s", gcrURL)

	req, err := http.NewRequest("GET", gcrURL, nil)
	if err != nil {
		log.Fatalf("%v", err)
	}
	req = req.WithContext(ctx)

	client := http.DefaultClient
	res, err := client.Do(req)
	if err != nil {
		log.Fatalf("%v", err)
	}

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		log.Fatalf("could not read response body: %s", err.Error())
	}

	var apiResponse = new(gcrAPIResponse)
	err = json.Unmarshal(body, &apiResponse)
	if err != nil {
		log.Fatalf("Could not unmarshal json response: %s", err)
	}

	var result []string
	var imageUploaded int64
	var imageSha string
	for str, manif := range apiResponse.Manifests {
		tmpUploaded, err := strconv.ParseInt(manif.TimeCreatedMs, 10, 64)
		if err != nil {
			log.Warnf("Couldn't retrieve timestamp for %s, %s", gcrURL, str)
		}
		if tmpUploaded > imageUploaded {
			imageUploaded = tmpUploaded
			imageSha = str
		}
	}
	if imageSha != "" && imageUploaded != 0 {
		result = append(result, fmt.Sprintf("https://%sgcr.io/v2/%s%s@%s", region, project, path, imageSha))
	}

	for _, child := range apiResponse.Children {
		newPath := fmt.Sprintf("%s/%s", path, child)
		res, err := collectLatestImageUrls(ctx, project, region, newPath)
		if err != nil {
			log.Fatalf("Could not collect more images: %s", err.Error())
		}
		result = append(result, res...)
	}

	return result, nil
}

//FindVulnerabilityOccurrencesForImage returns vulnerability occurances
func FindVulnerabilityOccurrencesForImage(ctx context.Context, projectID string, doChanges bool, resourceURL string) ([]*grafeaspb.Occurrence, error) {
	var occurenceList []*grafeaspb.Occurrence

	if doChanges {
		client, err := containeranalysis.NewGrafeasV1Beta1Client(ctx)
		if err != nil {
			return nil, fmt.Errorf("NewGrafeasV1Beta1Client: %v", err)
		}
		defer client.Close()

		req := &grafeaspb.ListOccurrencesRequest{
			Parent: fmt.Sprintf("projects/%s", projectID),
			Filter: fmt.Sprintf("resourceUrl = %q kind = %q", resourceURL, "VULNERABILITY"),
		}
		it := client.ListOccurrences(ctx, req)
		for {
			occ, err := it.Next()
			if err == iterator.Done {
				break
			}
			if err != nil {
				return nil, fmt.Errorf("occurrence iteration error: %v", err)
			}
			occurenceList = append(occurenceList, occ)
		}
	}
	return occurenceList, nil
}

// getOccurrence retrieves and prints a specified Occurrence from the server.
func getOccurrence(occurrenceID, projectID string) (*grafeaspb.Occurrence, error) {
	// occurrenceID := path.Base(occurrence.name)
	ctx := context.Background()
	client, err := containeranalysis.NewGrafeasV1Beta1Client(ctx)
	if err != nil {
		return nil, fmt.Errorf("NewGrafeasV1Beta1Client: %v", err)
	}
	defer client.Close()

	req := &grafeaspb.GetOccurrenceRequest{
		Name: fmt.Sprintf("projects/%s/occurrences/%s", projectID, occurrenceID),
	}
	occ, err := client.GetOccurrence(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("client.GetOccurrence: %v", err)
	}
	return occ, nil
}

//WriteToSlack writes output to slack
func WriteToSlack(doChanges bool, message string, high int, total int) {
	changePrefix := ""
	if !doChanges {
		changePrefix = "[DRYRUN] "
	}
	api := slack.New(os.Getenv("SLACKKEY"))
	var highc string
	var countt string
	if high > 0 {
		highc = "B40404"
	} else {
		highc = "01DF01"
	}
	if total > 0 {
		countt = "B40404"
	} else {
		countt = "01DF01"
	}
	attachment := []slack.Attachment{
		slack.Attachment{
			Text:  fmt.Sprintf("%s %d", "High number vars:", high),
			Color: fmt.Sprintf(highc),
		},
		slack.Attachment{
			Text:  fmt.Sprintf("%s %d", "total number vars:", total),
			Color: fmt.Sprintf(countt),
		},
		slack.Attachment{
			Text: "Get details",
			Actions: []slack.AttachmentAction{
				slack.AttachmentAction{
					Type: "button",
					Text: "Browse logs",
					URL:  "https://gcsweb.build.kyma-project.io/gcs/kyma-prow-logs/logs/kyma-gcp-container-vulnerability-collector", // TODO: Find out if we can get this URL programmatically.
				},
			},
		},
	}
	var channelID, timestamp string
	if doChanges {
		var errSlackPost error
		channelID, timestamp, errSlackPost = api.PostMessage(os.Getenv("SLACKCHANNEL"), slack.MsgOptionText(message, false), slack.MsgOptionAttachments(attachment...))
		if errSlackPost != nil {
			log.Printf("%s\n", errSlackPost)
			return
		}
	}
	log.Infof("%sMessage successfully sent to channel %s at %s", changePrefix, channelID, timestamp)
}
